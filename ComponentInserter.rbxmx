<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX0DDD9B46B36341F8A10FF65E38B56F7D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">ComponentInserter</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX4CF455AEE41C4AC2AF52C8875BE9ADFC">
			<Properties>
				<ProtectedString name="Source"><![CDATA[-- This has got to be some of the messiest spaghetti code you've seen
-- But it's functional, it serves it's purpose, and that's what matters most

local selection = game:GetService("Selection")
local root = script.Parent
require(root.ConstructGUI)
local components = require(root.Components)
local attributeValues = require(root.AttributeValues)
local mainFrame = root.MainFrame
local componentTemplate = mainFrame.ComponentTemplate
local componentList = mainFrame.ComponentList
local searchBar = mainFrame.Search
local helpHeader = mainFrame.HelpHeader
local helpScroll = mainFrame.HelpScroll
local apiConsumer = require(root.APIConsumer)

local apiSuccess, api = apiConsumer.TryGetAPI()

local attributesMap = if apiSuccess then api.GetAttributesMap() else nil

local toolbar = plugin:CreateToolbar("Component Inserter")
local pluginButton = toolbar:CreateButton(
	"Insert StateComponents", -- Text below button
	"Insert StateComponents into your mission from a list, and get some handy explanations for them as well", -- Hovertext
	if settings().Studio.Theme.Name == "Dark" then "rbxassetid://117007439200128" else "rbxassetid://87985218227517" -- Button icon
)

local info = DockWidgetPluginGuiInfo.new(
	Enum.InitialDockState.Float, -- Where the widget initially appears at
	false, -- If the widget will be initially enabled
	false, -- If the widget will have its size and position reset every time the plugin is activated
	375, -- Default width
	600, -- Default height
	300, -- Minimum width
	225 -- Minimum height
)

local widget = plugin:CreateDockWidgetPluginGuiAsync(
	"ComponentInserter",
	info
)

widget.Title = "Component Inserter"

script.Parent.MainFrame.Parent = widget

local function InvertColor(color: Color3)
	return Color3.new(1 - color.R, 1 - color.G, 1 - color.B)
end

local function InvertTheme()
	for i, v in ipairs(mainFrame:GetDescendants()) do
		if v:IsA("GuiObject") then
			v.BackgroundColor3 = InvertColor(v.BackgroundColor3)
			
			if v:IsA("TextLabel") or v:IsA("TextButton") or v:IsA("TextBox") then
				v.TextColor3 = InvertColor(v.TextColor3)
				v.TextStrokeColor3 = InvertColor(v.TextStrokeColor3)
			end
		end
	end
end

local function ShowMain(show: boolean)
	searchBar.Visible = show
	componentList.Visible = show
	helpHeader.Visible = not show
	helpScroll.Visible = not show
end

local function GetComponentAttributes(stateComponent: string)
	local returnTable = {}
	
	if apiSuccess and attributesMap[stateComponent] then
		for i, v in pairs(attributesMap[stateComponent]) do
			returnTable[i] = v[2]
		end
	end
	
	if components[stateComponent] then
		for i, v in pairs(components[stateComponent].Attributes) do
			if v[3] then continue end
			if returnTable[i] then continue end
			returnTable[i] = attributeValues[v[1]]
		end
	end
	
	return returnTable
end

local function InsertStateComponent(stateComponent: string)
	if not components[stateComponent] and not attributesMap[stateComponent] then
		warn("Attempted to insert StateComponent with invalid name")
		return
	end
	
	local debugMission = workspace:FindFirstChild("DebugMission")
	
	if not debugMission then
		warn("No DebugMission folder found")
		return
	end
	
	local stateComponentsFolder = debugMission:FindFirstChild("StateComponents")
	
	if not stateComponentsFolder then
		stateComponentsFolder = Instance.new("Folder")
		stateComponentsFolder.Name = "StateComponents"
		stateComponentsFolder.Parent = debugMission
		print("Couldn't find StateComponents folder in DebugMission and created a new one")
	end
	
	local newComponent = Instance.new("BoolValue")
	newComponent.Name = stateComponent
	newComponent.Parent = stateComponentsFolder
	newComponent:SetAttribute("Type", stateComponent)
	
	for attribute, value in pairs(GetComponentAttributes(stateComponent)) do
		newComponent:SetAttribute(attribute, value)
	end
	
	selection:Set({newComponent})
end

function LoadComponentHelp(stateComponent: string)
	if not components[stateComponent] then
		warn("Attempted to load help for invalid StateComponent name")
		return
	end

	helpHeader.ComponentTitle.Text = stateComponent

	local componentTable = components[stateComponent]
	local attributeTable = componentTable.Attributes

	local finalText = componentTable.HelpText

	local attributeKeys = {}
	for i, v in pairs(attributeTable) do
		table.insert(attributeKeys, i)
	end

	table.sort(attributeKeys, function(v1: string, v2: string)
		local val1 = v1:lower()
		local val2 = v2:lower()

		for i = 1, math.min(val1:len(), val2:len()) do
			if val1:byte(i, i) < val2:byte(i, i) then
				return true
			elseif val1:byte(i, i) > val2:byte(i, i) then
				return false
			end
		end
		
		return val1:len() < val2:len()
	end)

	for i, v in ipairs(attributeKeys) do
		finalText ..= "\n\n<b>" .. v .. " [" .. attributeTable[v][1] .. "]:</b> " .. attributeTable[v][2]
	end

	helpScroll.TextLabel.Text = finalText
	
	helpScroll.CanvasPosition = Vector2.zero

	ShowMain(false)
end

local function PopulateComponentList()
	local newComponentFrame
	componentList.CanvasSize = UDim2.new(0, 0, 0, 0)

	for i, v in pairs(components) do
		newComponentFrame = componentTemplate:Clone()

		newComponentFrame.Name = i
		newComponentFrame.ComponentName.Text = i
		newComponentFrame.Visible = true

		newComponentFrame.Parent = componentList
		
		newComponentFrame.ComponentName.Activated:Connect(function()
			InsertStateComponent(i)
		end)
		
		newComponentFrame.HelpButton.Activated:Connect(function()
			LoadComponentHelp(i)
		end)

		componentList.CanvasSize += UDim2.new(0, 0, 0, 37)
	end
end

local function ClearComponentList()
	for i, v in ipairs(componentList:GetChildren()) do
		if v:IsA("Frame") then v:Destroy() end
	end
end

PopulateComponentList()

searchBar.Changed:Connect(function(property: string)
	if property ~= "Text" then return end
	
	componentList.CanvasPosition = Vector2.zero
	
	for i, v in ipairs(componentList:GetChildren()) do
		if not v:IsA("Frame") then continue end
		
		if searchBar.Text == "" then v.Visible = true continue end
		
		if v.Name:lower():find(searchBar.Text:lower()) then
			v.Visible = true
		else
			v.Visible = false
		end
	end
end)

helpHeader.BackButton.Activated:Connect(function()
	ShowMain(true)
end)

pluginButton.Click:Connect(function()
	widget.Enabled = not widget.Enabled
end)

if settings().Studio.Theme.Name == "Light" then
	InvertTheme()
end

settings().Studio.ThemeChanged:Connect(function()
	InvertTheme()
end)
]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{A35B8B45-397F-4A87-A9EE-45CE18147058}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX80CA7008D9944E3EB80BA47F3EEC05C7">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local template = {
	Component = {
		HelpText = "Text",
		Attributes = {
			
		},
	},
}

local components = {
	AlarmedBehaviorOverride = {
		HelpText = "Overrides the behavior of specified bots with a given CustomBehavior when they enter combat",
		Attributes = {
			BotServerTag = {"string", "The bot tag that the CustomBehavior will apply to"},
			CustomBehavior = {"CustomBehavior", "The CustomBehavior to apply; for more information on CustomBehavior, consult the documentation"},
		},
	},
	AlertRaiseCondition = {
		HelpText = "Raises the alert level when a specific condition is met",
		Attributes = {
			Amount = {"number", "The amount that the alert level will raise"},
			Condition = {"Expression -> boolean", "When true, this AlertRaiseCondition will activate"},
			MaxValue = {"number", "The maximum value this AlertRaiseCondition can raise the alert level to"},
			MinValue = {"number", "The minimum value this AlertRaiseCondition can raise the alert level to"},
			Reason = {"CustomString", "The notification text that will appear when this AlertRaiseCondition activates"},
		},
	},
	AutoConversationTrigger = {
		HelpText = "Makes specified bot(s) forcefully trigger a conversation with the player when they are in range and a specific condition is met",
		Attributes = {
			Active = {"Expression -> boolean", "When true, specified bot(s) will attempt to trigger a conversation with the player when they are nearby"},
			BotClientTag = {"string", "The client-side bot tag to affect"},
		}
	},
	BlackoutScreen = {
		HelpText = "Fades out the player's view to a dark screen when a specified condition is true",
		Attributes = {
			Active = {"Expression -> boolean", "When true, the player's screen is covered in darkness"},
			Speed = {"number", "The amount of time that it takes, in seconds, for the dark screen to fade in and out"},
		},
	},
	BodyAltTrigger = {
		HelpText = "Adds an alternate (G) interaction trigger to the dead or unconscious body/bodies of specified bot(s)",
		Attributes = {
			BotClientTag = {"string", "The client-side bot tag to apply the trigger to"},
			BotServerTag = {"string", "The server-side bot tag to apply the trigger to"},
			ClientVisible = {"Expression -> boolean", "When false, the local player will not be able to see or interact with the trigger"},
			HoldTime = {"number", "The amount of time the trigger must be held, in seconds, to complete"},
			ServerEnabled = {"Expression -> boolean", "When false, no player will be able to see or interact with the trigger"},
			SubtitleKey = {"CustomString", "The text to display under the title text of the trigger"},
			TitleKey = {"CustomString", "The large text to display on the trigger"},
			TriggerLocalNotification = {"CustomString", "The notification to display to the player who interacts with the trigger"},
			TriggerNotification = {"CustomString", "The notification to display to all players when the trigger is interaction with"},
			TriggerVariable = {"string", "The name of the variable to increment when the trigger is interacted with"},
		},
	},
	BotAltTrigger = {
		HelpText = "Adds an alternate (G) interaction trigger to specified bot(s)",
		Attributes = {
			AllowHostages = {"boolean", "Applies this trigger to specified bots who are hostages"},
			AllowPatroling = {"boolean", "Applies this trigger to specified bots who are not pacified (yes there is a typo in the attribute name)"},
			BotClientTag = {"string", "The client-side bot tag to apply the trigger to"},
			BotServerTag = {"string", "The server-side bot tag to apply the trigger to"},
			ClientVisible = {"Expression -> boolean", "When false, the local player will not be able to see or interact with the trigger"},
			HoldTime = {"number", "The amount of time the trigger must be held, in seconds, to complete"},
			ServerEnabled = {"Expression -> boolean", "When false, no player will be able to see or interact with the trigger"},
			SubtitleKey = {"CustomString", "The text to display under the title text of the trigger"},
			TitleKey = {"CustomString", "The large text to display on the trigger"},
			TriggerLocalNotification = {"CustomString", "The notification to display to the player who interacts with the trigger"},
			TriggerNotification = {"CustomString", "The notification to display to all players when the trigger is interaction with"},
			TriggerVariable = {"string", "The name of the variable to increment when the trigger is interacted with"},
		},
	},
	BotItemSpawn = {
		HelpText = "Spawns an item into the inventory of specified bot(s) when a specific condition is met",
		Attributes = {
			BotServerTag = {"string", "The bot tag to affect"},
			Condition = {"Expression -> boolean", "When true, activates the BotItemSpawn"},
			Item = {"string", "The item to give"},
			ItemTag = {"string", "The item tag to apply to the given item"},
		},
	},
	BotStateTracker = {
		HelpText = "Tracks the status(es) of specified bot(s)",
		Attributes = {
			BotServerTag = {"string", "The bot tag for this trigger to track"},
			DeathCountVariable = {"string", "The name of the variable whose value will be set to the amount of dead bots with the specified tag"},
			FleeCountVariable = {"string", "The name of the variable whose value will be set to the amount of fleeing bots with the specified tag"},
			HostageCountVariable = {"string", "The name of the variable whose value will be set to the amount of bots held hostage with the specified tag"},
			IncapacitationCountVariable = {"string", "The name of the variable whose value will be set to the amount of dead, hostage, and unconscious bots with the specified tag"},
			TotalCountVariable = {"string", "The name of the variable whose value will be set to the total amount of bots with the specified tag"},
		},
	},
	CombatSpawner = {
		HelpText = "Spawns enemies in combat based on various specified parameters",
		Attributes = {
			Active = {"Expression -> boolean", "When true, allows this CombatSpawner to function"},
			AllowDespawn = {"boolean", "If true, allows combat enemies spawned to despawn (usually, you should keep this at true)"},
			CustomCombatData = {"string", "The name of a table in the CustomCombatData table to pull unit stats from"},
			EnemyType = {"string", "Defines the type (outfit) of enemies spawned, such as Swat, Palisade, Criminal, and HalcyonOperator"},
			EnemyWeapons = {"string", "The pool of weapons enemies can spawn with, with each weapon name being separated by a bar (|); use duplicate entries to increase the chances of specific weapons being spawned"},
			["EnemyWeaponsWave(1-9)"] = {"string", "A new attribute can be set for numbers 1 through 9; has the same formatting as EnemyWeapons, and overrides EnemyWeapons for specific waves", true},
			FlowMap = {"string", "The name of the CombatFlowMap to tie enemies to"},
			ReinforcementPool = {"string", "The name of the ReinforcementPool StateComponent to use to further define enemy spawns"},
			SpawnCap = {"Expression -> number", "The maximum number of combat units that can be alive at the same time"},
			SpawnsBlockedVariable = {"string", "The name of the variable that will be set to true if all possible spawn locations for enemies are unable to spawn units"},
			SpawnSquads = {"boolean", "If true, enemies will spawn in squads of up to 3 units at a time"},
			SpawnTags = {"string", "Determines which combat spawners enemies will spawn at"},
			TimeBetweenSpawns = {"Expression -> number", "The amount of time between enemy spawns, in seconds"}
		},
	},
	ConditionalStateUpdate = {
		HelpText = "Watches a specified variable for a change to a truthy value; after a change is made to the variable, another specified variable will be incremented depending on whether or not a specific condition is true",
		Attributes = {
			ActiveVariable = {"string", "The name of the variable to be incremented after the Watch variable is updated if Condition is true"},
			Condition = {"Expression -> boolean", "The condition that must be true for ActiveVariable to be set once Watch is updated"},
			InactiveVariable = {"string", "The name of the variable to be incremented after the Watch variable is updated if Condition is false"},
			Watch = {"string", "The name of the variable that will be watched for updates"},
		},
	},
	ConversationGenericSocialEngineering = {
		HelpText = "Defines a Social Engineering conversation prompt for specified bot(s)",
		Attributes = {
			BotServerTag = {"string", "The bot tag to apply the conversation prompt to"},
			Dialogue = {"CustomString", "A single dialogue string for the player's operator to say"},
			Disguise = {"string", "The disguise the player must wear to use the prompt"},
			Icon = {"string", "The icon for the prompt to display; can choose from: ChatCancel, ChatGeneric, ChatOpenDoor, ChatGoBack, ChatIntimidate, ChatLocked, and ChatArrow"},
			IntimidationLevel = {"Expression -> number", "The level of Intimidation required to use this prompt"},
			Label = {"CustomString", "The small dialogue sample to display after the prompt's Text value and perk requirements"},
			Notification = {"CustomString", "The notification text to display to the player after using the prompt"},
			NotificationDelay = {"number", "The time delay, in seconds, between using the prompt and receiving the notitification, if one is set"},
			SetVariable = {"string", "The name of the variable to increment after using this prompt"},
			SocialEngineeringLevel = {"Expression -> number", "The level of Social Engineering required to use the prompt"},
			Text = {"CustomString", "The text to display on the prompt"},
			Visible = {"Expression", "When false, this prompt will be invisible and uninteractable to players"},
		},
	},
	ConversationResponseCustomBehavior = {
		HelpText = "Defines a Social Engineering conversation prompt for specified bot(s) that apply a CustomBehavior to the bot(s)",
		Attributes = {
			BotServerTag = {"string", "The bot tag to apply the conversation prompt to"},
			CustomBehavior = {"CustomBehavior", "The CustomBehavior to apply; for more information on CustomBehavior, consult the documentation"},
			Dialogue = {"CustomString", "A single dialogue string for the player's operator to say"},
			DisableReason = {"Expression -> CustomString", "An expression returning a CustomString key if the prompt should be disabled"},
			SocialEngineeringLevel = {"Expression", "The level of Social Engineering required to use the prompt"},
		}
	},
	CustomBehaviorCondition = {
		HelpText = "Applies a CustomBehavior to bots with a specified tag when a specific condition is met",
		Attributes = {
			BotServerTag = {"string", "The bot tag the CustomBehavior will apply to"},
			Condition = {"Expression -> boolean", "When true, applies the CustomBehavior to the specified bot(s)"},
			CustomBehavior = {"CustomBehavior", "The CustomBehavior to apply; for more information on CustomBehavior, consult the documentation"},
			LoopApply = {"boolean", "If true, the CustomBehavior will continue to apply even if the bot is interrupted"},
			Priority = {"string", "Can be set to Custom1, Custom2, Custom3, Custom4, or Custom5; a higher number means a higher priority for the CustomBehavior applied, and values of Custom3 or above will prevent the player from initiating conversation with the bot(s)"},
		},
	},
	CustomHack = {
		HelpText = "Creates a hack that can be deployed on a specified network node",
		Attributes = {
			BlockDeallocation = {"boolean", "If true, the hack cannot be cancelled once started or deployed"},
			DeployCost = {"number", "The base amount of network resources that this hack takes to deploy"},
			DeployedOnceVariable = {"string", "The name of the variable that will be incremented once this hack is first deployed, and will not change if the hack is deallocated or redeployed"},
			DeployedVariable = {"string", "The name of the variable that will be incremented when the hack is deployed"},
			DeployTime = {"number", "The amount of ticks this hack takes to deploy; ticks go by at a rate of four per second in Stealth and one per second in Loud"},
			DescriptionKey = {"CustomString", "The text to display when the hack is hovered over in the hacking UI, formatted as \"TITLE - Short action description\""},
			Difficulty = {"Expression -> number", "The level of Advanced Protocols needed to deploy the hack"},
			DisableReason = {"Expression -> CustomString", "An expression returning a CustomString key if the hack should be disabled; the hack will be visible but uninteractable"},
			IconId = {"string", "The asset ID of the icon to display for the hack in the hacking UI"},
			IsDeployedVariable = {"string", "The name of the variable whose value will be set to true when the hack is currently allocated"},
			NameKey = {"CustomString", "The title text of the hack shown in the allocation list, as well as, if the hack is a primary hack, the interaction prompt"},
			NodeId = {"number", "The network node ID of the device the hack can be deployed on"},
			PauseCondition = {"Expression -> boolean", "When true, progress on the hack being deployed will be paused"},
			PrimaryHack = {"boolean", "If true, the hack may be deployed without a hacking tablet through directly interacting with the device the hack may be deployed on"},
			Priority = {"number", "The priority of which hack should be shown first as a primary hack interaction prompt, should multiple primary hacks be linked to the same device; a higher number means higher priority"},
			ProgressVariable = {"string", "The name of the variable whose value will be set to a decimal representing the deployment progress of the hack"},
			ScriptedBehavior = {"string", "This attribute currently has no use"},
			SubtitleKey = {"CustomString", "The text to be displayed under the title text of the interacttion prompt of the hack, if the hack is a primary hack"},
			Suspicion = {"number", "The amount of hacking risk to add for every tick the hack takes to deploy"},
			Visible = {"Expression -> boolean", "When false, the hack will be invisible and uninteractable for all players"},
		},
	},
	CoverFillSpawner = {
		HelpText = "Spawns enemies in combat based on various specified parameters to fill specific cover spots",
		Attributes = {
			Active = {"Expression -> boolean", "When true, allows this CombatSpawner to function"},
			ActiveVariable = {"string", "The name of the variable whose value will be set to the number of currently alive enemies spawned from this CoverFillSpawner"},
			CoverSearchLimit = {"number", "The maximum number of cells away a valid cover spot can be from the spawn point of an enemy"},
			CoverTags = {"string", "The specific CoverTag of cover spots for enemies spawned from this spawner to use"},
			CustomCombatData = {"string", "The name of a table in the CustomCombatData table to pull unit stats from"},
			EnemyType = {"string", "Defines the type (outfit) of enemies spawned, such as Swat, Palisade, Criminal, and HalcyonOperator"},
			EnemyWeapons = {"string", "The pool of weapons enemies can spawn with, with each weapon name being separated by a bar (|); use duplicate entries to increase the chances of specific weapons being spawned"},
			["EnemyWeaponsWave(1-9)"] = {"string", "A new attribute can be set for numbers 1 through 9; has the same formatting as EnemyWeapons, and overrides EnemyWeapons for specific waves", true},
			FillFrequency = {"number", "The amount of time between unit spawns, in seconds"},
			ReinforcementPool = {"string", "The name of the ReinforcementPool StateComponent to use to further define enemy spawns"},
			SpawnCap = {"Expression -> number", "The maximum number of combat units that can be alive at the same time"},
			SpawnsBlockedVariable = {"string", "The name of the variable that will be set to true if all possible spawn locations for enemies are unable to spawn units"},
			SpawnTags = {"string", "Determines which combat spawners enemies will spawn at"},
		},
	},
	DelayedStateUpdate = {
		HelpText = "Watches a specified variable for a change in its value; after a change is made to the variable, another specified variable will be incremented after a specified amount of time has passed",
		Attributes = {
			DelayTime = {"number", "The amount of time in seconds it takes for the variable set in SetVariable to be incremented after the variable set in Watch is updated"},
			OnlyMatch = {"boolean", "If false, all updates to the Watch variable will trigger individual increments to the SetVariable variable; if true, the SetVariable variable will be incremented only after the DelayTime passes with no further updates to the Watch variable"},
			SetVariable = {"string", "The name of the variable to be incremented"},
			Watch = {"string", "The name of the variable that will be watched for updates"},
		},
	},
	FileUITrigger = {
		HelpText = "Displays a paper file with custom text on the player's screen when a specific condition is met",
		Attributes = {
			Font = {"string", "The name of the font to use for the text on the file"},
			Lines = {"string", "A list of CustomStrings to be displayed on the file in a randomized order, separated by bars (|)"},
			NoExtraPaper = {"boolean", "If true, extra papers will not be displayed behind the paper file on-screen"},
			NoFolder = {"boolean", "If true, a folder will not be displayed behind the paper file on-screen"},
			ShowTape = {"boolean", "If true, tape will be shown with the paper file on-screen"},
			TextScale = {"number", "The scale of the text to be shown on the file"},
			Trigger = {"Expression -> boolean", "When true, the file will be shown on the player's screen"},
		},
	},
	HackableDoor = {
		HelpText = "Adds an informational node to the hacking map attached to a specified node showing that a door may be hacked open through the attached node",
		Attributes = {
			NetworkId = {"number", "The network node ID of this node"},
			NetworkLink = {"number", "The network node ID of the device to connect this node to"},
		},
	},
	HackableElevator = {
		HelpText = "Adds an informational node to the hacking map attached to a specified node showing that an elevator may be called through a hack on the attached node",
		Attributes = {
			NetworkId = {"number", "The network node ID of this node"},
			NetworkLink = {"number", "The network node ID of the device to connect this node to"},
		},
	},
	HackingNodeHighlight = {
		HelpText = "Applies an objective marker to a specified hacking node (and optionally a specified hack) in the hacking UI when a specific condition is met",
		Attributes = {
			Active = {"Expression -> boolean", "When true, an objective marker will be placed on a specified hacking node and hack in the hacking UI"},
			HackDesc = {"CustomString", "The DescriptionKey of the hack that will be marked"},
			IncludeTraversal = {"boolean", "If true, the Traversal hack on the target node will also have an objective marker"},
			NodeId = {"number", "The network node ID of the device to apply the marker to in the hacking UI"},
			ObjectiveType = {"number", "The type of objective marker to place; 1 for Main, 2 for Stealth, 3 for Combat, 4 for Intel (large), 5+ for Intel (small)"},
		}
	},
	HackingNodeStatus = {
		HelpText = "Reports on the status of a specified network node",
		Attributes = {
			CompromisedVariable = {"string", "The name of the variable whose value will be set to true when the specified node is compromised"},
			DisabledVariable = {"string", "The name of the variable whose value will be set to true when the specified node is disabled"},
			GlobalVariable = {"boolean", "This attribute is no longer in use"},
			NetworkId = {"number", "The network node ID of the device to check the status of"},
		},
	},
	HiddenShuffle = {
		HelpText = "Creates a biased shuffle for randomized FreeTrigger and HiddenWallSafe props",
		Attributes = {
			BackCount = {"number", "The amount of padding at the end of the player's search; the player will always succeed in their search before they reach this many searches before the end"},
			ClientFailCountVariable = {"string", "The name of the local variable whose value will be set to the amount of times the local player has had a failed check in this shuffle"},
			FailCountVariable = {"string", "The name of the variable whose value will be set to the amount of times all players have had a failed check in this shuffle"},
			FrontCount = {"number", "The amount of padding at the start of the player's search; the player will only succeed in their search after they've already searched this many times"},
			HiddenShuffleId = {"string", "The ID to pair with a set randomized FreeTriggers or HiddenWallSafes"},
			RevealAllCondition = {"Expression -> boolean", "When true, the position of the correct search will be locked into place, and HiddenWallSafes will have their photos taken away"},
			RevealCount = {"number", "The amount of searches that count as successful included in the shuffle"},
			RevealCountVariable = {"string", "The name of the variable whose value will be set to the amount of times all players have had a successful check in this shuffle"},
			Seed = {"number", "The seed number used for shuffling"},
		},
	},
	IntelCharacterPortrait = {
		HelpText = "Adds an image of a specified bot as a node to the intel map that is visible when a specific condition is met",
		Attributes = {
			BackgroundColor = {"string", "The color of the background of the portrait, represented using a hex code (no hashtag)"},
			ClientTag = {"string", "The client-side tag of the bot to create a render of; portrait instead shows the text \"UNKNOWN APPEARANCE\" if no tag is provided"},
			HiddenColor = {"string", "The color of the background of the portrait when no ClientTag is set, represented using a hex code (no hashtag)"},
			IntelNodeId = {"string", "The unique identifier for this intel map node"},
			Visible = {"Expression -> boolean", "When true, this intel map node will be visible on the intel map"},
		},
	},
	IntelConnection = {
		HelpText = "Creates a link between two specified nodes on the intel map when a specific condition is met",
		Attributes = {
			Link0 = {"string", "The IntelNodeId of the first intel map node to link"},
			Link1 = {"string", "The IntelNodeId of the second intel map node to link"},
			Visible = {"Expression -> boolean", "When true, this connection will be visible on the intel map"},
		},
	},
	IntelPrimaryText = {
		HelpText = "Adds a text label as a node to the intel map that is visible when a specific condition is met",
		Attributes = {
			BackgroundColor = {"string", "The color of the background of the node, represented using a hex code (no hashtag)"},
			IntelNodeId = {"string", "The unique identifier for this intel map node"},
			Text = {"CustomString", "The text to display on the node"},
			Visible = {"Expression -> boolean", "When true, this intel map node will be visible on the intel map"},
		},
	},
	IntelSubText = {
		HelpText = "Adds a text label beneath an intel map node to the intel map that is visible when a specific condition is met",
		Attributes = {
			IntelNodeId = {"string", "The IntelNodeId of the intel map node to put this IntelSubText under"},
			LayoutOrder = {"Expression -> number", "Determines display order relative to other IntelSubText nodes; the one with the lowest value will appear on top"},
			Text = {"CustomString", "The text to display on the node"},
			Uppercase = {"boolean", "If true, the text will be displayed in uppercase"},
			Visible = {"Expression -> boolean", "When true, this intel map node will be visible on the intel map"},
		},
	},
	ItemStateTracker = {
		HelpText = "Tracks the status(es) of item(s) with a specified tag",
		Attributes = {
			BotHeldCountVariable = {"string", "The name of the variable whose value will be set to the amount of items with the specified tag carried by bots"},
			ClientHeldCountVariable = {"string", "The name of the local variable whose value will be set to the amount of items with the specified tag carried by the local player"},
			GroundCountVariable = {"string", "The name of the variable whose value will be set to the amount of items with the specified tag that are loose throughout the mission"},
			ItemTag = {"string", "The item tag to track"},
			TotalHeldCountVariable = {"string", "The name of the variable whose value will be set to the amount of items with the specified tag that are being carried by players"},
		},
	},
	ItemSwapCondition = {
		HelpText = "Swaps out item(s) with a specified tag out for a different item when a specific condition is met",
		Attributes = {
			Condition = {"Expression -> boolean", "When true, this ItemSwapCondition will be activated"},
			SwapItemTag = {"string", "The item tag that the new item will have"},
			SwapItemType = {"string", "The item that the new item will be"},
			TargetItemTag = {"string"," The item tag that is the target of the swap"},
		},
	},
	LerpOperation = {
		HelpText = "Performs linear interpolation between two numbers",
		Attributes = {
			AlwaysUpdate = {"boolean", "If true, the output variable will be updated whenever the input values are updated"},
			Delta = {"Expression -> number", "The percentage of the input values to use"},
			OutputVariable = {"string", "The name of the variable whose value will be the output for the operation"},
			UpdateClock = {"Expression -> number", "Can be used if AlwaysUpdate is false; updates the output value whenever this value is updated"},
			Value0 = {"Expression -> number", "The first value to input for the operation"},
			Value1 = {"Expression -> number", "The second value to input for the operation"},
		},
	},
	LocalChat = {
		HelpText = "Starts a specified dialogue when a specific condition is met",
		Attributes = {
			Active = {"Expression -> boolean", "When true, the specified dialogue will play"},
			CombatOnly = {"boolean", "If true, the dialogue will only trigger during Loud"},
			DelayStart = {"number", "The amount of time that it takes, in seconds, for the dialogue to be triggered after the Active condition is met"},
			Dialogue = {"string", "The name of the dialogue table to be triggered"},
			StealthOnly = {"boolean", "If true, the dialogue will only trigger during Stealth"},
			TriggerOnce = {"boolean", "If true, the dialogue will only be triggered once"},
		},
	},
	LocalWeaponTracker = {
		HelpText = "Tracks the status of the local player's equipped weapon",
		Attributes = {
			HoldingWeaponVariable = {"string", "The name of the local variable whose value will be set to true when the local player is holding a weapon"},
			LoadedAmmoVariable = {"string", "The name of the local variable whose value will be set to the amount of ammo the local player has loaded in their weapon"},
			TotalAmmoVariable = {"string", "The name of the local variable whose value will be set to the total amount of ammo the local player has for their weapon"},
		}
	},
	LocationCard = {
		HelpText = "Shows a card with a title and subtitle on-screen when a specific condition is met",
		Attributes = {
			Active = {"Expression -> boolean", "When true, this LocationCard will activate"},
			Subtitle = {"CustomString", "The subtitle to show on the card"},
			Title = {"CustomString", "The title to show on the card"},
		},
	},
	MissionCompleteTrigger = {
		HelpText = "Ends the mission as a successful completion when a specific condition is met",
		Attributes = {
			CompleteVariable = {"string", "The name of the variable whose value will be set to true when this MissionCompleteTrigger is activated"},
			Condition = {"Expression -> boolean", "When true, the mission will be completed"},
			Timeout = {"number", "The amount of time, in seconds, that Condition must be true to trigger the mission completion"},
		}
	},
	MissionFailedTrigger = {
		HelpText = "Ends the mission as a failure when a specific condition is met",
		Attributes = {
			FailedVariable = {"string", "The name of the variable whose value will be set to true when this MissionFailedTrigger is activated"},
			Condition = {"Expression -> boolean", "When true, the mission will fail"},
			Timeout = {"number", "The amount of time, in seconds, that Condition must be true to trigger the failure of the mission"},
		}
	},
	MusicController = {
		HelpText = "Plays specified background music based on a priority stack",
		Attributes = {
			ActivePriority = {"Expression -> number", "The priority value for this MusicController; the MusicController with the highest priority value will play its music"},
			MusicType = {"string", "Currently non-functional"},
			NoLoop = {"boolean", "If true, the music played by this MusicController will not loop when it is finished playing"},
			TrackId = {"string", "The asset ID of the audio to be played as background music by this MusicController"},
			Volume = {"number", "The volume of the music played by this MusicController, as a decimal between zero and one"},
		},
	},
	NetworkRouter = {
		HelpText = "Adds an informational node to the hacking map attached to a specified node showing that off-site camera monitoring starts at the attached node",
		Attributes = {
			NetworkId = {"number", "The network node ID of this node"},
			NetworkLink = {"number", "The network node ID of the device to connect this node to"},
		},
	},
	Notification = {
		HelpText = "Notifies the player with specified text at the top of their screen when a specific condition is met",
		Attributes = {
			Condition = {"Expression -> boolean", "When true, the notification is displayed to the player"},
			Notification = {"CustomString", "The text of the notification to be displayed"},
		},
	},
	RandomBotSpawner = {
		HelpText = "Spawns random bots at RandomBotSpawnLocation props when a specific condition is met",
		Attributes = {
			Behavior = {"string", "The behavior used by spawned bots; can be PatrolWalk, WorkWithBreaks, Bodyguard, or PassingCivilian"},
			CivilianHighlight = {"boolean", "If true, spawned bots will be highlighted white when marked"},
			Class = {"string", "The class of spawned bots determining what areas they may enforce trespassing in"},
			DetectionSpeed = {"number", "The multiplier for how fast spawned bots will detect players they can detect"},
			EnforceClass = {"string", "The name of the EnforceClass table used by spawned bots"},
			HostageDifficulty = {"number", "The level of Intimidation required to take spawned bots hostage"},
			Nodes = {"string", "The name of the nodes folder spawned bots use if the PatrolWalk, WorkWithBreaks, or Bodyguard behaviors are used"},
			NodesBreak = {"string", "The name of the nodes folder used when spawned bots go on break if the WorkWithBreaks behavior is used"},
			ObjectiveHighlight = {"boolean", "If true, spawned bots will be highlighted purple when marked"},
			Outfit = {"string", "The preset outfit used by spawned bots (use CivilianOutfit for random civilian outfits)"},
			Profile = {"string", "The profile spawned bots use to determine certain behaviors"},
			SpawningActive = {"Expression -> boolean", "When true, random bots may spawn"},
			SpawnTimeMin = {"number", "The minimum amount of time, in seconds, before a new random bot is spawned"},
			SpawnTimeMax = {"number", "The maximum amount of time, in seconds, before a new random bot is spawned"},
			Title = {"CustomString", "The title of spawned bots shown in conversations and body prompts"},
			Weapon = {"string", "The weapon spawned bots have on them"},
		},
	},
	ReinforcementPool = {
		HelpText = "Further defines spawns for CombatSpawner StateComponents by supplying them with waves of units",
		Attributes = {
			ActiveVariable = {"string", "The name of the variable whose value will be set to the number of units from this pool currently fighting players"},
			PoolLimit = {"Expression -> number", "Defines the number of units in a combat unit pool"},
			PoolName = {"string", "The name of the pool referenced by CombatSpawner StateComponents"},
			RemainingVariable = {"string", "The name of the variable whose value will be set to the number of currently active units spawned from this pool plus the number of units still available in this pool"},
			WaveResetTime = {"number", "The amount of time it takes, in seconds, for the reinforcement pool to fill back up with units after the last unit from the pool is sent out"},
			WaveResetTimeDecrease = {"number", "The amount of time the reset time for the pool decreases, in seconds, every time the pool is reset"},
			WaveResetTimeMinimum = {"number", "The minimum amount of time the pool reset time can go down to, in seconds"},
			WaveStateVariable = {"string", "Currently non-functional"},
			WaveVariable = {"string", "The name of the variable whose value is set to the current wave number the pool is on"},
		},
	},
	ScriptedBotSpawn = {
		HelpText = "Spawns a specified bot template into the mission when a specific condition is met",
		Attributes = {
			Condition = {"Expression -> boolean", "When true, the specified bot template will be spawned into the mission"},
			TemplateId = {"string", "The name of the bot template within the BotTemplates folder to spawn"},
		}
	},
	ScriptedTakedown = {
		HelpText = "Knocks out or kills specified bot(s) when a specific condition is met",
		Attributes = {
			BotServerTag = {"string", "The bot tag to affect"},
			Lethal = {"boolean", "If true, affected bot(s) will be killed rather than knocked unconscious"},
			Trigger = {"Expression -> boolean", "When true, this ScriptedTakedown will activate"},
		},
	},
	SearchPatternCondition = {
		HelpText = "Triggers specified bots to begin roaming the nodes defined in their SearchArea attribute when a specific condition is met",
		Attributes = {
			BotServerTag = {"string", "The bot tag targeted by the SearchPatternCondition"},
			Condition = {"Expression -> boolean", "When true, specified bots will begin roaming their SearchArea nodes"},
		},
	},
	SniperSpawner = {
		HelpText = "Spawns SWAT snipers at specified nodes when a specific condition is met",
		Attributes = {
			Active = {"Expression -> boolean", "When true, snipers will begin spawning"},
			InitialSpawns = {"number", "The initial number of snipers to spawn as soon as they become active"},
			Nodes = {"string", "The name of the folder of nodes to spawn snipers on"},
			RespawnRate = {"number", "The time it takes, in seconds, for snipers to respawn after being killed"},
		},
	},
	StateScript = {
		HelpText = "Executes custom code within the limits of the StateScript language",
		Attributes = {
			Run = {"Expression -> boolean", "When true, this StateScript will begin running, and will stop when this value is false; generally shouldn't be used alongside the TriggerEvent attribute"},
			ScriptSource = {"StateScript", "The StateScript code to run; for more information on StateScripts, read the documentation or wiki page"},
			TriggerEvent = {"Expression -> boolean", "When updated with a non-zero value, a new instance of the StateScript will be executed; generally shouldn't be used alongside the Run attribute"},
		},
	},
	StateUpdate = {
		HelpText = "Watches a specified variable for a change in its value; after a change is made to the variable, another specified variable will be incremented",
		Attributes = {
			SetInternal = {"string", "The name of an internal variable to be incremented"},
			SetVariable = {"string", "The name of a global variable to be incremented"},
			Watch = {"string", "The name of the variable that will be watched for updates"},
		},
	},
	TimerComponent = {
		HelpText = "Activates a custom, modifiable timer",
		Attributes = {
			Enabled = {"Expression -> boolean", "When true, the timer will be activated"},
			Frequency = {"Expression -> number", "The amount of time between timer ticks, in seconds; defaults to 1"},
			Increment = {"Expression -> number", "The amount the timer value is incremented or decremented every timer tick"},
			Offset = {"Expression -> number", "The amount the timer value is offset by"},
			Paused = {"Expression -> boolean", "When true, the timer will stop ticking"},
			SetFormattedVariable = {"string", "The name of the variable whose value will be set to the amount of time remaining on the timer, formatted as XX:XX"},
			SetVariable = {"string", "The name of the variable that will be used to store the timer value"},
			StartValue = {"Expression -> number", "The starting value of the timer when it is first activated"},
			TargetValue = {"Expression -> number", "The value that the timer will stop at when it is reached"},
		},
	},
	VariableShuffle = {
		HelpText = "Given Prefix0 and Prefix1, as well as two specified sets of values Set0 and Set1, shuffles the values of each set, then pairs values of each set with their corresponding prefix to create a set of variable names and pairs values of each set with the new variables of the opposite prefix to create the values for the variables such that for every Prefix0X that has a value of Y, there is a Prefix1Y that has a value of X",
		Attributes = {
			InternalOnly = {"boolean", "If true, created variables will be stored as internals"},
			Prefix0 = {"string", "The first variable prefix to use"},
			Prefix1 = {"string", "The second variable prefix to use"},
			Seed = {"Expression -> number", "The seed number to use for randomization"},
			Set0 = {"string", "The first set of values to use, with each value separated by a bar (|)"},
			Set1 = {"string", "The second set of values to use, with each value separated by a bar (|)"},
		},
	},
}

return components
]]></ProtectedString>
				<string name="ScriptGuid">{5D28438D-96F5-48CF-ABBC-88BA835F1D4D}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Components</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX84C4BBD850444B90AD24C5A961782FA2">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local attributeValues = {
	boolean = false,
	number = 0,
	string = "",
	CustomString = "",
	Expression = "",
	["Expression -> boolean"] = "",
	["Expression -> number"] = "",
	["Expression -> string"] = "",
	["Expression -> CustomString"] = "",
	CustomBehavior = "",
	StateScript = "",
}

return attributeValues
]]></ProtectedString>
				<string name="ScriptGuid">{F7C74623-A7B4-4999-966D-5461E301319B}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">AttributeValues</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX0477B6AA3F5346CF999B2EBA8D015FEB">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	This module is provided for convenience of consumers of the serializer API
	providing a reference implementation for correctly retrieving and validating a reference to the API table

	For a working example of a plugin making use of this API via this module
	see: https://github.com/Sprixitite/InfiltrationEngine-PrefabSystem
]]

local coreGui = game:GetService("CoreGui")

export type Token = string
export type Hook = (...any) -> nil
export type HookType = "APIExtensionLoaded"|"APIExtensionUnloaded"|"PreSerialize"|"PreSerializeMissionSetup"|"SerializerUnloaded"
export type APIExtension = { [string] : (...any) -> ...any }

export type APIReference = {
	-- Generic
	GetAPIVersion 			: () -> number,
	GetCodeVersion 			: () -> number,
	GetAttributesMap 		: () -> { [string] : { [number] : any } },
	GetAttributeTypes 		: () -> { [string] : number },
	GetRegistrantFactory	: (author: string, plugin: string) -> ((hookName: string) -> string), 

	-- HookTypes
	GetHookTypes 			: () -> { [number] : string },
	IsHookTypeValid 		: (hookType: string, warnCaller: string?) -> boolean,

	-- Hooks
	AddHook 				: (hookType: HookType, registrant: string, hook: Hook, hookState: {any}?) -> Token,
	RemoveHook 				: (token: Token) -> nil,

	-- APIExtensions
	AddAPIExtension 		: (name: string, author: string, contents: APIExtension) -> Token,
	GetAPIExtension			: (name: string, author: string) -> APIExtension,
	RemoveAPIExtension		: (token: Token) -> nil
}

type AnyTbl = { [string] : any }

local APIConsumer = {}

local function ValidateArgTypes(fname: string, ...) : boolean
	local args = {...}
	for _, argSettings in ipairs(args) do
		local argName = argSettings[1]
		local argValue = argSettings[2]
		local argType = type(argValue)
		local argExpectedType = argSettings[3]
		if argType ~= argExpectedType then
			warn(`Invalid argument {argName} passed to function {fname} - expected type {argExpectedType} but got {argType}!`)
			return false
		end
	end
	return true
end

APIConsumer.ValidateArgTypes = ValidateArgTypes

-- Yields until timeOut is elapsed or API is found
APIConsumer.WaitForAPI = function(timeOut: number?) : APIReference?
	timeOut = if timeOut == nil then math.huge else timeOut

	if not ValidateArgTypes(
		"WaitForAPI",
		{"timeOut", timeOut, "number"}
		) then return end

	local presenceIndicator = coreGui:WaitForChild("InfilEngine_SerializerAPIAvailable", timeOut)
	if not presenceIndicator then return end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return end

	return apiTbl
end

-- Attempt to get the API without blocking - returns false + nil if unavailable, otherwise returns true + APIReference
APIConsumer.TryGetAPI = function() : (boolean, APIReference?)
	local presenceIndicator = coreGui:FindFirstChild("InfilEngine_SerializerAPIAvailable")
	if not presenceIndicator then return false, nil end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return false, nil end

	return true, apiTbl
end

-- Never returns unless there's an error
-- Continually wires up handling of serializer load/unload as well as unloading of consumer plugin as needed
-- Avoid doing this yourself if you can help it
APIConsumer.DoAPILoop = function<StateT>(
	callerPlugin: Plugin,
	srcname: string,
	loadedClbck: (api: APIReference, state: StateT) -> nil,
	unloadedClbck: (api: APIReference, state: StateT) -> nil, 
	state: StateT?
) : never
	state = if state == nil then {} else state

	if typeof(callerPlugin) ~= "Instance" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {typeof(callerPlugin)}!`)
		return
	end

	if callerPlugin.ClassName ~= "Plugin" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {callerPlugin.ClassName}!`)
		return
	end

	if not ValidateArgTypes(
		"DoAPILoop", 
		{"srcname", srcname, "string"},
		{"loadedClbck", loadedClbck, "function"},
		{"unloadedClbck", unloadedClbck, "function"},
		{"state", state, "table"}
		) then return end

	local api = APIConsumer.WaitForAPI()
	if api == nil then return APIConsumer.DoAPILoop(callerPlugin, srcname, loadedClbck, unloadedClbck, state) end

	loadedClbck(api, state)

	local pluginUnloadCallback
	local unloadToken

	pluginUnloadCallback = callerPlugin.Unloading:Connect(function()
		pluginUnloadCallback:Disconnect()
		pluginUnloadCallback = nil
		unloadedClbck(api, state)
		if unloadToken ~= nil then api.RemoveHook(unloadToken) end
	end)

	unloadToken = api.AddHook("SerializerUnloaded", `APIConsumerFramework_{srcname}`, function()
		if pluginUnloadCallback then pluginUnloadCallback:Disconnect() pluginUnloadCallback = nil end
		unloadedClbck(api, state)
		task.spawn(APIConsumer.DoAPILoop, callerPlugin, srcname, loadedClbck, unloadedClbck, state)
	end)
end

return APIConsumer]]></ProtectedString>
				<string name="ScriptGuid">{4C7ABB9E-ADEC-48F3-B053-E385B84750CC}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">APIConsumer</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX2A1CCEAED5C4447EBE132497398D6E91">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[=[
 d888b  db    db d888888b      .d888b.      db      db    db  .d8b.  
88' Y8b 88    88   `88'        VP  `8D      88      88    88 d8' `8b 
88      88    88    88            odD'      88      88    88 88ooo88 
88  ooo 88    88    88          .88'        88      88    88 88~~~88 
88. ~8~ 88b  d88   .88.        j88.         88booo. 88b  d88 88   88    @uniquadev
 Y888P  ~Y8888P' Y888888P      888888D      Y88888P ~Y8888P' YP   YP  CONVERTER 
]=]

-- Instances: 14 | Scripts: 0 | Modules: 0 | Tags: 0
local G2L = {};


-- StarterGui.ScreenGui.MainFrame
G2L["2"] = Instance.new("Frame", script.Parent);
G2L["2"]["BorderSizePixel"] = 0;
G2L["2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2"]["Name"] = [[MainFrame]];
G2L["2"]["BackgroundTransparency"] = 0.9;


-- StarterGui.ScreenGui.MainFrame.Title
G2L["3"] = Instance.new("TextLabel", G2L["2"]);
G2L["3"]["TextWrapped"] = true;
G2L["3"]["BorderSizePixel"] = 0;
G2L["3"]["TextSize"] = 14;
G2L["3"]["TextScaled"] = true;
G2L["3"]["BackgroundColor3"] = Color3.fromRGB(26, 27, 32);
G2L["3"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["3"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["3"]["Size"] = UDim2.new(1, 0, 0, 25);
G2L["3"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3"]["Text"] = [[Component Inserter]];
G2L["3"]["LayoutOrder"] = 1;
G2L["3"]["Name"] = [[Title]];


-- StarterGui.ScreenGui.MainFrame.Search
G2L["4"] = Instance.new("TextBox", G2L["2"]);
G2L["4"]["Name"] = [[Search]];
G2L["4"]["BorderSizePixel"] = 0;
G2L["4"]["TextWrapped"] = true;
G2L["4"]["TextSize"] = 14;
G2L["4"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["4"]["TextScaled"] = true;
G2L["4"]["BackgroundColor3"] = Color3.fromRGB(26, 27, 32);
G2L["4"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["4"]["PlaceholderText"] = [[Search...]];
G2L["4"]["Size"] = UDim2.new(1, 0, 0, 35);
G2L["4"]["Position"] = UDim2.new(0, 0, 0, 30);
G2L["4"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["4"]["Text"] = [[]];
G2L["4"]["LayoutOrder"] = 2;


-- StarterGui.ScreenGui.MainFrame.UIListLayout
G2L["5"] = Instance.new("UIListLayout", G2L["2"]);
G2L["5"]["Padding"] = UDim.new(0, 5);
G2L["5"]["SortOrder"] = Enum.SortOrder.LayoutOrder;


-- StarterGui.ScreenGui.MainFrame.ComponentList
G2L["6"] = Instance.new("ScrollingFrame", G2L["2"]);
G2L["6"]["Active"] = true;
G2L["6"]["BorderSizePixel"] = 0;
G2L["6"]["Name"] = [[ComponentList]];
G2L["6"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["6"]["Size"] = UDim2.new(1, 0, 1, -70);
G2L["6"]["ScrollBarImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6"]["Position"] = UDim2.new(0.08564, 0, 0.07949, 0);
G2L["6"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6"]["ScrollBarThickness"] = 10;
G2L["6"]["LayoutOrder"] = 3;
G2L["6"]["BackgroundTransparency"] = 0.98;


-- StarterGui.ScreenGui.MainFrame.ComponentList.UIListLayout
G2L["7"] = Instance.new("UIListLayout", G2L["6"]);
G2L["7"]["Padding"] = UDim.new(0, 2);


-- StarterGui.ScreenGui.MainFrame.ComponentTemplate
G2L["8"] = Instance.new("Frame", G2L["2"]);
G2L["8"]["Visible"] = false;
G2L["8"]["BorderSizePixel"] = 0;
G2L["8"]["BackgroundColor3"] = Color3.fromRGB(33, 35, 41);
G2L["8"]["Size"] = UDim2.new(1, -10, 0, 35);
G2L["8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8"]["Name"] = [[ComponentTemplate]];


-- StarterGui.ScreenGui.MainFrame.ComponentTemplate.ComponentName
G2L["9"] = Instance.new("TextButton", G2L["8"]);
G2L["9"]["TextWrapped"] = true;
G2L["9"]["BorderSizePixel"] = 0;
G2L["9"]["TextSize"] = 14;
G2L["9"]["TextScaled"] = true;
G2L["9"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["9"]["BackgroundColor3"] = Color3.fromRGB(129, 129, 129);
G2L["9"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["9"]["BackgroundTransparency"] = 0.65;
G2L["9"]["Size"] = UDim2.new(1, -35, 0, 35);
G2L["9"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["9"]["Name"] = [[ComponentName]];


-- StarterGui.ScreenGui.MainFrame.ComponentTemplate.HelpButton
G2L["a"] = Instance.new("TextButton", G2L["8"]);
G2L["a"]["TextWrapped"] = true;
G2L["a"]["TextStrokeTransparency"] = 0;
G2L["a"]["BorderSizePixel"] = 0;
G2L["a"]["TextSize"] = 14;
G2L["a"]["TextScaled"] = true;
G2L["a"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["a"]["BackgroundColor3"] = Color3.fromRGB(161, 109, 230);
G2L["a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["a"]["BackgroundTransparency"] = 0.65;
G2L["a"]["Size"] = UDim2.new(0, 35, 1, 0);
G2L["a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["a"]["Text"] = [[?]];
G2L["a"]["Name"] = [[HelpButton]];
G2L["a"]["Position"] = UDim2.new(1, -35, 0, 0);


-- StarterGui.ScreenGui.MainFrame.HelpHeader
G2L["b"] = Instance.new("Frame", G2L["2"]);
G2L["b"]["Visible"] = false;
G2L["b"]["BorderSizePixel"] = 0;
G2L["b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b"]["Size"] = UDim2.new(1, 0, 0, 35);
G2L["b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b"]["Name"] = [[HelpHeader]];
G2L["b"]["LayoutOrder"] = 2;
G2L["b"]["BackgroundTransparency"] = 1;


-- StarterGui.ScreenGui.MainFrame.HelpHeader.ComponentTitle
G2L["c"] = Instance.new("TextLabel", G2L["b"]);
G2L["c"]["TextWrapped"] = true;
G2L["c"]["BorderSizePixel"] = 0;
G2L["c"]["TextSize"] = 14;
G2L["c"]["TextScaled"] = true;
G2L["c"]["BackgroundColor3"] = Color3.fromRGB(26, 27, 32);
G2L["c"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["c"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["c"]["Size"] = UDim2.new(1, -35, 1, 0);
G2L["c"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["c"]["Text"] = [[Component]];
G2L["c"]["LayoutOrder"] = 1;
G2L["c"]["Name"] = [[ComponentTitle]];
G2L["c"]["Position"] = UDim2.new(0, 35, 0, 0);


-- StarterGui.ScreenGui.MainFrame.HelpHeader.BackButton
G2L["d"] = Instance.new("TextButton", G2L["b"]);
G2L["d"]["TextWrapped"] = true;
G2L["d"]["TextStrokeTransparency"] = 0;
G2L["d"]["BorderSizePixel"] = 0;
G2L["d"]["TextSize"] = 14;
G2L["d"]["TextScaled"] = true;
G2L["d"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["d"]["BackgroundColor3"] = Color3.fromRGB(129, 129, 129);
G2L["d"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["d"]["BackgroundTransparency"] = 0.65;
G2L["d"]["Size"] = UDim2.new(0, 35, 0, 35);
G2L["d"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["d"]["Text"] = [[X]];
G2L["d"]["Name"] = [[BackButton]];


-- StarterGui.ScreenGui.MainFrame.HelpScroll
G2L["e"] = Instance.new("ScrollingFrame", G2L["2"]);
G2L["e"]["Visible"] = false;
G2L["e"]["Active"] = true;
G2L["e"]["BorderSizePixel"] = 0;
G2L["e"]["CanvasSize"] = UDim2.new(0, 0, 0, 1600);
G2L["e"]["Name"] = [[HelpScroll]];
G2L["e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["e"]["Size"] = UDim2.new(1, 0, 1, -70);
G2L["e"]["ScrollBarImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e"]["Position"] = UDim2.new(0.08564, 0, 0.07949, 0);
G2L["e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["e"]["ScrollBarThickness"] = 10;
G2L["e"]["LayoutOrder"] = 3;
G2L["e"]["BackgroundTransparency"] = 0.98;


-- StarterGui.ScreenGui.MainFrame.HelpScroll.TextLabel
G2L["f"] = Instance.new("TextLabel", G2L["e"]);
G2L["f"]["TextWrapped"] = true;
G2L["f"]["TextStrokeTransparency"] = 0.5;
G2L["f"]["BorderSizePixel"] = 0;
G2L["f"]["TextSize"] = 18;
G2L["f"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["f"]["TextYAlignment"] = Enum.TextYAlignment.Top;
G2L["f"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["f"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["f"]["BackgroundTransparency"] = 1;
G2L["f"]["RichText"] = true;
G2L["f"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["f"]["Size"] = UDim2.new(1, -20, 1, 0);
G2L["f"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["f"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);



return G2L["2"];]]></ProtectedString>
				<string name="ScriptGuid">{6B2308E5-48AD-4E9C-B54A-994FBCC70000}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ConstructGUI</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>